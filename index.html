<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Monads to the Rescue</title>

		<meta name="description" content="Slides for Codemania presentation 'Monads to the Rescue'">
		<meta name="author" content="Katie Miller">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

		<style>
			.bracket {color:#CC00FF; font-weight:bold;}
			.function {color:#FFFF66;}
			.accumulator {color:#FF9900;}
			.result {color:#00FFFF;}
			.initial-hide {opacity:0; visibility:hidden;}
			.initial-front {position: absolute; z-index: 1;}
			.initial-back {position: absolute; z-index: 2;}
			#superdef-context.visible ~ #superdef-points #superdef-context-point{opacity:1; visibility:visible;}
			#superdef-costume.visible ~ #superdef-points #superdef-costume-point{opacity:1; visibility:visible;}
			#superdef-purpose.visible ~ #superdef-points #superdef-purpose-point{opacity:1; visibility:visible;}
			#superdef-powers.visible ~ #superdef-points #superdef-powers-point{opacity:1; visibility:visible;}
			#sequence-liftlist.visible ~ #sequence-liftmaybe{opacity:0; visibility:hidden; display:none;}	
			#sequence-sequencelist.visible ~ #sequence-sequencemaybe{opacity:0; visibility:hidden; display:none;}	
			#sequence-liftpartial2.visible ~ #sequence-liftpartial{opacity:0; visibility:hidden;}	
                        @-webkit-keyframes explode { 
			   0% { opacity: 1; }
                           80% { opacity: 1; -webkit-transform: scale( 4 ); -moz-transform: scale( 4 ); -ms-transform: scale( 4 ); -o-transform: scale( 4 ); transform: scale( 4 ); } 
                           100% { opacity: 0; -webkit-transform: scale( 2 ); -moz-transform: scale( 2 ); -ms-transform: scale( 2 ); -o-transform: scale( 2 ); transform: scale( 2 ); } 
		        }
                        @-moz-keyframes explode { 
			   0% { opacity: 1; }
                           80% { opacity: 1; -webkit-transform: scale( 4 ); -moz-transform: scale( 4 ); -ms-transform: scale( 4 ); -o-transform: scale( 4 ); transform: scale( 4 ); } 
                           100% { opacity: 0; -webkit-transform: scale( 2 ); -moz-transform: scale( 2 ); -ms-transform: scale( 2 ); -o-transform: scale( 2 ); transform: scale( 2 ); } 
		        }
                        @-ms-keyframes explode { 
			   0% { opacity: 1; }
                           80% { opacity: 1; -webkit-transform: scale( 4 ); -moz-transform: scale( 4 ); -ms-transform: scale( 4 ); -o-transform: scale( 4 ); transform: scale( 4 ); } 
                           100% { opacity: 0; -webkit-transform: scale( 2 ); -moz-transform: scale( 2 ); -ms-transform: scale( 2 ); -o-transform: scale( 2 ); transform: scale( 2 ); } 
		        }
                        @-o-keyframes explode { 
			   0% { opacity: 1; }
                           80% { opacity: 1; -webkit-transform: scale( 4 ); -moz-transform: scale( 4 ); -ms-transform: scale( 4 ); -o-transform: scale( 4 ); transform: scale( 4 ); } 
                           100% { opacity: 0; -webkit-transform: scale( 2 ); -moz-transform: scale( 2 ); -ms-transform: scale( 2 ); -o-transform: scale( 2 ); transform: scale( 2 ); } 
		        }
                        @keyframes explode { 
			   0% { opacity: 1; }
                           80% { opacity: 1; -webkit-transform: scale( 4 ); -moz-transform: scale( 4 ); -ms-transform: scale( 4 ); -o-transform: scale( 4 ); transform: scale( 4 ); } 
                           100% { opacity: 0; -webkit-transform: scale( 2 ); -moz-transform: scale( 2 ); -ms-transform: scale( 2 ); -o-transform: scale( 2 ); transform: scale( 2 ); } 
		        }
                        .reveal .slides section .fragment.explosion {
                            opacity: 0;
                        }
                        .reveal .slides section .fragment.explosion.visible {
			    -webkit-animation-name: explode;
                            -moz-animation-name: explode;
                            -ms-animation-name: explode;
                            -o-animation-name: explode;
                            animation-name: explode;

			    -webkit-animation-duration: 1s;
			    -moz-animation-duration: 1s;
			    -ms-animation-duration: 1s;
			    -o-animation-duration: 1s;
			    animation-duration: 1s;
                        }
	               	      
                </style>
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

				<section>
					<h1>Monads to the Rescue</h1>
					<img src="images/lambdadude.png" style="background: none; border: none; box-shadow: none; margin-top: 0px; width: 25%;"/>
					<h3>Katie Miller (<a href="http://twitter.com/codemiller" target="_blank">@codemiller</a>)<br>Developer at <a href="http://redhat.com" target="_blank">Red Hat</a></h3>
				</section>
				<section>
					<strong>Superhero (ˈsuːpəˌhɪərəʊ):</strong> Any of various <span class="fragment highlight-red" data-fragment-index="1" id="superdef-context">comic-strip</span> characters with <span class="fragment highlight-red" data-fragment-index="4" id="superdef-powers">superhuman abilities or magical powers</span>, wearing a <span class="fragment highlight-red" data-fragment-index="2" id="superdef-costume">distinctive costume</span>, and <span class="fragment highlight-red" data-fragment-index="3" id="superdef-purpose">fighting against evil</span>&nbsp;&nbsp;&nbsp;-&nbsp;<a href="http://dictionary.reference.com/browse/superhero" target="_blank">World English Dictionary</a>
					<p>&nbsp;</p>
					<div id="superdef-points"> 
						<ul>
							<li class="initial-hide" id="superdef-context-point">Found in particular setting: <em>Where might you find monads?</em></li>
							<li class="initial-hide" id="superdef-costume-point">Distinctive costume: <em>What do monads look like?</em></li>
							<li class="initial-hide" id="superdef-purpose-point">Force for good: <em>What are monads good for?</em></li>
							<li class="initial-hide" id="superdef-powers-point">Special, unexpected abilities: <em>What special or unexpected abilities do monads have?</em></li>
						</ul>
					</div>
				</section>
				<section>
				<section>
					<div style="position: fixed; left: 4%"><img src="images/context-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; top: 50%; left: 3%"><img src="images/purpose.png" style="background: none; border: none; box-shadow: none;"/></div>
					<img src="images/monadman-lgr.png" style="background: none; border: none; box-shadow: none;" width="513px"/>
					<div style="position: fixed; left: 70%; top: 1%"><img src="images/costume.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; left: 71%; top: 49%"><img src="images/powers.png" style="background: none; border: none; box-shadow: none;"/></div>
            			</section>
				<section>
					<h3>Functional Programming Paradigm</h3>
					</p>
					<ul>
						<li class="fragment">"[I]ts fundamental operation is the application of functions to arguments." - John&nbsp;Hughes</li>
						<li class="fragment">Pure functions don't have side-effects; they are referentially transparent</li>
						<li class="fragment">Functions are first-class; higher-order functions take other functions as arguments or return a function as a result</li>
					</ul>
				</section>
				<section>
					<h3>FP Features</h3>
					</p>
					<ul>
						<li>Immutable data</li>
						<li>Lazy evaluation</li>
						<li>Lambda expressions</li>
						<li>Closures</li>
						<li>Pattern matching</li>
						<li>Alternatives to loops</li>
						<li>Partial application/currying</li>
					</ul>
				</section>
				<section>
					<h3>Haskell Example</h3>
					</p>
					<pre><code class="haskell">myList = ["a"] --"a":[]

<span class="fragment">myFunc :: (Num a, Enum a) => [b] -> Int -> [(a,b)]</span>
<span class="fragment">myFunc (x:xs) n = foldr (\i acc -> (i,x):acc) [] (take n [1..])</span>

<span class="fragment">-- foldr :: (a -> b -> b) -> b -> [a] -> b</span>

</code><code class="no-highlight"><span class="fragment">myFunc myList 3 = 1<span class="function">:</span>2<span class="function">:</span>3<span class="function">:</span><span class="accumulator">[]</span></span>
<span class="fragment">1 <span class="function">(\i acc -> (i,x):acc)</span> 2 <span class="function">(\i acc -> (i,x):acc)</span> 3 <span class="function">(\i acc -> (i,x):acc)</span> <span class="accumulator">[]</span></span>
<span class="fragment"><span class="bracket">(</span>1 <span class="function">(\i acc -> (i,x):acc)</span> <span class="bracket">(</span>2 <span class="function">(\i acc -> (i,x):acc)</span> <span class="bracket">(</span>3 <span class="function">(\i acc -> (i,x):acc)</span> <span class="accumulator">[]</span><span class="bracket">)))</span></span>
<span class="fragment"><span class="bracket">(</span>1 <span class="function">(\i acc -> (i,x):acc)</span> <span class="bracket">(</span>2 <span class="function">(\i acc -> (i,x):acc)</span> <span class="result">[(3,"a")]</span><span class="bracket">))</span></span>
<span class="fragment"><span class="bracket">(</span>1 <span class="function">(\i acc -> (i,x):acc)</span> <span class="result">[(2,"a"),(3,"a")]</span><span class="bracket">)</span></span>
<span class="fragment"><span class="result">[(1,"a"),(2,"a"),(3,"a")]</span></span>

</code><code class="haskell"><span class="fragment">myFunc myList = ?</span>	
<span class="fragment">myFunc myList :: (Num a, Enum a) => Int -> [(a, Char)]</span></code></pre>
				</section>
				<section>
					<h3>Java 8 Lambdas</h3>
					</p>
					<pre><code class="java">public interface Function&lt;T, R&gt; {
    public R apply(T t);
}

public interface BiFunction&lt;T, U, R&gt; {
    R apply(T t, U u);
}

<span class="fragment">public static List&lt;Integer&gt; map(List&lt;Integer&gt; list, Function&lt;Integer, Integer&gt; func) {
    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
    for (Integer num : list) {
        result.add(<span class="fragment highlight-green">func.apply(num)</span>);
    }
    return result;
}</span>

<span class="fragment">System.out.println(map(Arrays.asList(1, 2, 3), <span class="fragment highlight-green">i -> i + 1</span>));
// [2, 3, 4]</span></code></pre>
				</section>
				<section>
					<h3>FP Benefits</h3>
					</p>
					<ul>
						<li>Ability to reason about program behaviour; can use equational reasoning</li>
						<li>Higher-order functions and lazy evaluation facilitate more modular programs; code&nbsp;reuse</li>
						<li>Removing side-effects aids concurrent programming</li>
						<li>Programs often more succinct</li>
						<li>Automated test generation with tools such as QuickCheck</li>
					</ul>
				</section>
				</section>
				<section>
				<section>
					<div style="position: fixed; left: 4%"><img src="images/context.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; top: 50%; left: 3%"><img src="images/purpose.png" style="background: none; border: none; box-shadow: none;"/></div>
					<img src="images/monadman-lgr.png" style="background: none; border: none; box-shadow: none;" width="513px"/>
					<div style="position: fixed; left: 70%; top: 1%"><img src="images/costume-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; left: 71%; top: 49%"><img src="images/powers.png" style="background: none; border: none; box-shadow: none;"/></div>
            			</section>
				<section>
					<h3>The Monad Costume</h3>
					<p>
					A monad is a structure that puts values in a computational context and implements two&nbsp;functions:
					</p>
					<ul>
						<li class="fragment">Return: <strong>a &rarr; Monad a</strong><br>(also known as Unit/Pure)</li>						
						<li class="fragment">Bind: <strong>(Monad a, (a &rarr; Monad b)) &rarr; Monad&nbsp;b</strong><br>(also known as FlatMap/SelectMany)</li>		
					</ul>
					</p>
					<span class="fragment"><img src="images/letter_s.png" style="background: none; border: none; box-shadow: none;"/>
					<span class="fragment"><img src="images/right-arrow.svg" style="background: none; border: none; box-shadow: none; padding-bottom: 35px;"/><img src="images/super_s.png" style="background: none; border: none; box-shadow: none;"/><br>
					<span class="fragment"><img src="images/super_s.png" style="background: none; border: none; box-shadow: none;"/></span>
					<span class="fragment"><img src="images/right-arrow.svg" style="background: none; border: none; box-shadow: none; padding-bottom: 35px; padding-right: 15px"/><img src="images/letter_s.png" style="background: none; border: none; box-shadow: none;"/></span>
					<span class="fragment"><img src="images/right-arrow.svg" style="background: none; border: none; box-shadow: none; padding-bottom: 35px; padding-left: 15px;"/><img src="images/super_t.png" style="background: none; border: none; box-shadow: none;"/>
				</section>
				<section>
					<span>"Any time you start with something which you pull apart and use to compute a new something of that same type, you have a <strong>monad</strong>. It's really as simple as that. If it sounds like I'm describing almost all of your code, then good, that means you're starting to catch on." -&nbsp;<a href="http://www.codecommit.com/blog/ruby/monads-are-not-metaphors" target="_blank">Daniel Spiewak</a></span>
				</section>
				<section>
					<h3>A Few Monads</h3>
					</p>
					<ul>
						<li>Identity Monad</li>
						<li><span class="fragment highlight-blue">Maybe/Option Monad</span></li>
						<li><span class="fragment highlight-blue">List Monad</span></li>
						<li>IO Monad</li>
						<li>State Monad</li>
						<li>Writer Monad</li>
						<li>Reader Monad</li>
						<li>Continuation Monad</li>
					</ul>
				</section>	
				<section>
					<h3>Monad Laws</h3>
					</p>
					<ul>
						<li>Left Identity: return x >>= f ≡ f x</li>
						<li>Right Identity: m >>= return ≡ m</li>
						<li>Associativity: (m >>= f) >>= g ≡ m >>= (\x -> f x >>= g)</li>
					</ul>
				</section>		
				<section>
					<h3>Maybe/Option Monad</h3>
					</p>
					<span>Context of possible value absence</span>
<pre><code class="haskell">-- data Maybe a = Just a | Nothing 

<span class="fragment">returnMaybe :: a -> Maybe a</span>
<span class="fragment">returnMaybe a = Just a</span>

<span class="fragment">returnMaybe 7
-- Just 7</span>

<span class="fragment">bindMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b</span>
<span class="fragment">Nothing `bindMaybe` f = Nothing</span>
<span class="fragment">Just a `bindMaybe` f = f a</span>

<span class="fragment">Just 7 `bindMaybe` (\x -> returnMaybe (x+1))
-- Just 8</span>

<span class="fragment">Nothing `bindMaybe` (\x -> returnMaybe (x+1))
-- Nothing</span>

<span class="fragment">Just 7 `bindMaybe` (\x -> returnMaybe (x+1)) `bindMaybe` (\y -> returnMaybe (y*5))
-- Just 40</span>
</code></pre>
				</section>
				<section>
					<h3>Maybe in Java 8</h3>
<pre><code class="java">public abstract class Maybe&lt;A&gt; {

    <span class="fragment">public abstract &lt;B&gt; Maybe&lt;B&gt; bind(Function&lt;A, Maybe&lt;B&gt;&gt; func);</span>

    <span class="fragment">public static &lt;A&gt; Just&lt;A&gt; just(A value) {
        return new Just&lt;&gt;(value);
    }</span>

    <span class="fragment">public static &lt;A&gt; Nothing&lt;A&gt; nothing() {
        return new Nothing&lt;&gt;();
    }</span>

    <span class="fragment">public static &lt;A&gt; Maybe&lt;A&gt; fromNullable(A value) {
        if (value == null) return nothing();
        else return just(value);
    }</span>
}
</code></pre>
				</section>
<section>
<pre><code class="java">private static final class Nothing&lt;A&gt; extends Maybe&lt;A&gt; {

    <span class="fragment">@Override
    public &lt;B&gt; Maybe&lt;B&gt; bind(Function&lt;A, Maybe&lt;B&gt;&gt; func) {
        return nothing();
    }</span>
}
</code></pre>
				</section>
				<section>
<pre><code class="java">private static final class Just&lt;A&gt; extends Maybe&lt;A&gt; {

    <span class="fragment">private final A value;

    private Just(A value) {
        this.value = value;
    }</span>

    <span class="fragment">@Override
    public &lt;B&gt; Maybe&lt;B&gt; bind(Function&lt;A, Maybe&lt;B&gt;&gt; func) {
        return func.apply(value);
    }</span>
}
</code></pre>		
				</section>
				<section>
					<h3>Maybe vs Null</h3>
<pre><code class="java">
public static Maybe&lt;Integer&gt; processIntegerWithMaybe(Maybe&lt;Integer&gt; maybeNum) {
    return <span class="fragment highlight-green">maybeNum.bind(x -> just(x + 1)).bind(y -> just(y * 5))</span>;
}

public static Integer processInteger(Integer num) {
    if (num == null) return null;
    // Or perhaps throw new IllegalArgumentException("Num cannot be null!");
    Integer incrementedNum = increment(num);
    if (incrementedNum == null) return null;
    Integer multipliedNum = multiplyByFive(incrementedNum);
    if (multipliedNum == null) return null;
    return multipliedNum;
}

public static Integer increment(Integer num) {
    return (num == null) ? null : num + 1;
}

public static Integer multiplyByFive(Integer num) {
    return (num == null) ? null : num * 5;
}
</code></pre>
				</section>
				<section>
					<h3>List Monad</h3>
					</p>
					<span>Context of non-determinism</span>
<pre><code class="haskell">-- picture a type declaration something like: data [a] = [] | a:[a]

<span class="fragment">returnList :: a -> [a]</span>
<span class="fragment">returnList a = [a]</span>

<span class="fragment">returnList "Bar"
-- ["Bar"]</span>

<span class="fragment">bindList :: [a] -> (a -> [b]) -> [b]</span>
<span class="fragment">bindList l f = foldr (\x acc -> f x ++ acc) [] l</span>

<span class="fragment">["Super","Spider","Bar"] `bindList` (\x -> returnList (x ++ "man"))
-- ["Superman","Spiderman","Barman"]</span>
</code></pre>
				</section>
				<section>
<pre><code class="java">public abstract class List&lt;A&gt; {
    <span class="fragment">public abstract &lt;B&gt; List&lt;B&gt; bind(Function&lt;A, List&lt;B&gt;&gt; func);</span>

    <span class="fragment">public abstract List&lt;A&gt; append(List&lt;A&gt; list);</span>

    <span class="fragment">public abstract &lt;B&gt; B foldRight(BiFunction&lt;A, B, B&gt; func, B acc);</span>

    <span class="fragment">public static &lt;A&gt; List&lt;A&gt; cons(A value, List&lt;A&gt; list) {
        return new ItemList&lt;A&gt;(value, list);
    }</span>

    <span class="fragment">public static &lt;A&gt; EmptyList&lt;A&gt; emptyList() {
        return new EmptyList&lt;&gt;(); 
    }</span>

    <span class="fragment">public static &lt;A&gt; List&lt;A&gt; itemList(A... values) {
        if (values.length == 0) return emptyList();
        List&lt;A&gt; list = emptyList();
        for (int i = values.length - 1; i &gt;= 0; i--) {
            list = cons(values[i], list);
        }
        return list;
    }</span>
}
</code></pre>
				</section>
				<section>
<pre><code class="java">private static class EmptyList&lt;A&gt; extends List&lt;A&gt; {

    <span class="fragment">@Override
    public &lt;B&gt; List&lt;B&gt; bind(Function&lt;A, List&lt;B&gt;&gt; func) {
        return emptyList();
    }</span>
}
</code></pre>
				</section>
				<section>
<pre><code class="java">private static class ItemList&lt;A&gt; extends List&lt;A&gt; {

    <span class="fragment">private final A value;
    private final List&lt;A&gt; next;

    private ItemList(A value, List&lt;A&gt; next) {
        this.value = value;
        this.next = next;
    }</span>

    <span class="fragment">@Override
    public &lt;B&gt; List&lt;B&gt; bind(Function&lt;A, List&lt;B&gt;&gt; func) {
        return foldRight((value, acc) -&gt; (func.apply(value)).append(acc), emptyList());
    }</span>
}
</code></pre>
				</section>	
				</section>
				<section>
				<section>
					<div style="position: fixed; left: 4%"><img src="images/context.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; top: 50%; left: 3%"><img src="images/purpose-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
					<img src="images/monadman-lgr.png" style="background: none; border: none; box-shadow: none;" width="513px"/>
					<div style="position: fixed; left: 70%; top: 1%"><img src="images/costume.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; left: 71%; top: 49%"><img src="images/powers.png" style="background: none; border: none; box-shadow: none;"/></div>
            			</section>
				<section>
					<h3>Why Monads Are Useful</h3>
					<p>
					They help to combat the perils of:
					</p>
					<ul>
						<li>Code duplication</li>
						<li>Unnecessary complexity</li>
						<li>Poor maintainability</li>
					</ul>
				</section>
				<section>
					<h3>Monadic Heroes</h3>
					</p>
					<ul>
						<li>Identity Monad: Can blend in anywhere</li>
						<li>Maybe Monad: If this hero succeeds, you'll know it</li>
						<li>List Monad: Can do many things at once</li>
						<li>IO Monad: Puts world manipulators where they belong</li>
						<li>State Monad: Always keeps track of the state of affairs</li>
						<li>Writer Monad: Never forgets a detail</li>
						<li>Reader Monad: Can tell what you're thinking</li>
						<li>Continuation Monad: Can travel through time</li>
					</ul>
				</section>
				<section>
					<h3>Maybe Monad Example Use</h3>
					</p>
<pre><code class="haskell">currencySupply = [(20, 5), (50, 10), (100, 1)]

<span class="fragment">-- lookup :: Eq a => a -> [(a, b)] -> Maybe b</span>

<span class="fragment">unitsLeft :: [(Int, Int)] -> Int -> Int -> Maybe Int</span>
<span class="fragment">unitsLeft supply val num = (lookup val supply) `bindMaybe` (\u -> if u - num < 0 
  then Nothing else returnMaybe (u - num))</span>

<span class="fragment">unitsLeft currencySupply 20 3
-- Just 2</span>

<span class="fragment">unitsLeft currencySupply 20 10
-- Nothing</span>

<span class="fragment">unitsLeft currencySupply 70 1
-- Nothing</span>
</code></pre>
				</section>
				<section>
<pre><code class="java">// public static &lt;K, V&gt; Maybe&lt;V&gt; lookup(List&lt;Tuple&lt;K, V&gt;&gt; tupleList, K key) { }

<span class="fragment">public static Maybe&lt;Integer&gt; unitsLeft(List&lt;Tuple&lt;Integer, Integer&gt;&gt; currencySupply,
  Integer value, Integer unitsWanted) {
    return lookup(currencySupply, value).bind(numUnits -&gt; (numUnits - unitsWanted &lt; 0) 
      ? nothing() : just(numUnits - unitsWanted));
}</span>	
</code></pre>
				</section>	
				<section>
					<h3>List Monad Example Use</h3>
					</p>
<pre><code class="haskell">listNotes :: [Int] -> [String] -> [String]
<span class="fragment">listNotes amts curs = amts `bindList` (\amt -> curs `bindList` (\cur -> 
  returnList (cur ++ (show amt))))</span>

<span class="fragment">listNotes [20, 50, 100] ["$AU", "$NZ"]
-- ["$AU20","$NZ20","$AU50","$NZ50","$AU100","$NZ100"]</span>	
</code></pre>
				</section>
				<section>
<pre><code class="java">public static &lt;String&gt;	 List&lt;String&gt; listNotes(List&lt;Integer&gt; amts, List&lt;String&gt; currs) {
    return amts.bind(amt -&gt; currs.bind(curr -&gt; itemList(curr + amt.toString())));
}
</code></pre>
				</section>
				</section>
				<section>	
				<section>
					<div style="position: fixed; left: 4%"><img src="images/context.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; top: 50%; left: 3%"><img src="images/purpose.png" style="background: none; border: none; box-shadow: none;"/></div>
					<img src="images/monadman-lgr.png" style="background: none; border: none; box-shadow: none;" width="513px"/>
					<div style="position: fixed; left: 70%; top: 1%"><img src="images/costume.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; left: 71%; top: 49%"><img src="images/powers-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
            			</section>
				<section>
					<span>Let's implement sequence...</span><br>
					<span class="fragment"><strong>List (Monad a)) &rarr; Monad (List a)</strong></span>
				</section>
				<section>
				<h3>Sequence Maybe Demo</h3>
<pre><code class="haskell">currencySupply = [(20, 5), (50, 10), (100, 1)]

checkComboServiceable :: [(Int, Int)] -> [(Int, Int)] -> Maybe [Int]
<span class="fragment">checkComboServiceable cur combo = sequenceMaybe (foldr (\(val,num) acc -> 
  (unitsLeft cur val num):acc) [] combo)</span>

<span class="fragment">checkComboServiceable currencySupply [(20, 1), (50, 1)]
-- Just [4,9]</span>

<span class="fragment">checkComboServiceable currencySupply [(20, 6), (50, 1)] 
-- Nothing</span>
</code></pre>
				</section>
				<section>
					<h3>Sequence List Demo</h3>
<pre><code class="haskell">createValueUnitPairs :: Int -> Int -> [(Int, Int)]
<span class="fragment">createValueUnitPairs amt val = zip (repeat val) [0..(amt `div` val)]</span>

<span class="fragment">createValueUnitPairs 70 20
-- [(20, 0), (20, 1), (20, 2), (20, 3)]</span>

<span class="fragment">combinations amt = sequenceList (foldr (\val acc -> 
  (createValueUnitPairs amt val):acc) [] (20, 50, 100))</span>

<span class="fragment">combinations 70
-- [[(20, 0), (50, 0), (100, 0)], 
--  [(20, 0), (50, 1), (100, 0)],
--  [(20, 1), (50, 0), (100, 0)],
--  [(20, 1), (50, 1), (100, 0)],
--  [(20, 2), (50, 0), (100, 0)],
--  [(20, 2), (50, 1), (100, 0)],
--  [(20, 3), (50, 0), (100, 0)],
--  [(20, 3), (50, 1), (100, 0)]]</span>
</code></pre>
				</section>
				<section>
					<h3>Implementing Sequence</h3>
<pre><code class="haskell">mapMaybe :: (a -> b) -> Maybe a -> Maybe b
<span class="fragment" data-fragment-index="2">mapMaybe f Nothing = Nothing
mapMaybe f (Just a) = Just (f a)</span>

<span class="fragment" data-fragment-index="1">liftMaybe :: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c</span>
<span class="fragment" data-fragment-index="3">liftMaybe f ma mb = (mapMaybe f ma) `bindMaybe` (`mapMaybe` mb)</span>

<span class="fragment" data-fragment-index="4">sequenceMaybe :: [Maybe a] -> Maybe [a]</span>
<span class="fragment" data-fragment-index="5">sequenceMaybe ls = foldr (\l acc -> liftMaybe (:) l acc) (returnMaybe []) ls</span>

<span class="fragment" data-fragment-index="6">sequenceMaybe [Just 4, Just 3, Just 7] = </span>
<span class="fragment" data-fragment-index="7">[Just 4, Just 3, Just 7]                 Just (7:[])</span>
<span class="fragment" data-fragment-index="8">[Just 4, Just 3]                         Just (3:[7])</span>
<span class="fragment" data-fragment-index="9">[Just 4]                                 Just (4:[3,7])</span>
<span class="fragment" data-fragment-index="10">[]                                       Just [4,3,7]</span>
</code></pre>
				</section>
				<section>
<pre><code class="haskell">mapList :: (a -> b) -> [a] -> [b]
mapList f l = foldr (\x acc -> (f x):acc) [] l

<span class="fragment" data-fragment-index="1">liftList :: (a -> b -> c) -> [a] -> [b] -> [c]</span>
<span class="fragment roll-in initial-back" data-fragment-index="4" id="sequence-liftlist">liftList f la lb = (mapList f la) `bindList` (`mapList` lb)</span><span class="fragment roll-in initial-front" data-fragment-index="3" id="sequence-liftmaybe">liftMaybe f ma mb = (mapMaybe f ma) `bindMaybe` (`mapMaybe` mb)</span>

<span class="fragment" data-fragment-index="2">sequenceList :: [[a]] -> [[a]]</span>
<span class="fragment roll-in initial-back" data-fragment-index="6" id="sequence-sequencelist">sequenceList ls = foldr (\l acc -> liftList (:) l acc) (returnList []) ls</span><span class="fragment roll-in initial-front" data-fragment-index="5" id="sequence-sequencemaybe">sequenceMaybe ls = foldr (\l acc -> liftMaybe (:) l acc) (returnMaybe []) ls</span>

<span class="fragment" data-fragment-index="9">sequenceList [[(20,0),(20,1),(20,2)],[(50,0),(50,1)]] = </span>
<span class="fragment" data-fragment-index="10">[[(20,0),(20,1),(20,2)],[(50,0),(50,1)]]                [(50,0):[],(50,1):[]]</span>
<span class="fragment" data-fragment-index="11">[[(20,0),(20,1),(20,2)]]                                [(20,0):[(50,0)],(20,0):[(50,1)],
                                                         (20,1):[(50,0)],(20,1):[(50,1)],
                                                         (20,2):[(50,0)],(20,2):[(50,1)]]</span>
<span class="fragment" data-fragment-index="13">[]                                                      [[(20,0),(50,0)],[(20,0),(50,1)],
                                                         [(20,1),(50,0)],[(20,1),(50,1)],
                                                         [(20,2),(50,0)],[(20,2),(50,1)]]</span>

<span class="fragment initial-back" data-fragment-index="12" id="sequence-liftpartial2">liftList (:) [(20,0),(20,1),(20,2)] [[(50,0)],[(50,1)]]
  = (mapList (:) [(20,0),(20,1),(20,2)]) `bindList` (`mapList` [[(50,0)],[(50,1)]])
  = [(\x -> (20,0):x),(\y -> (20,1):y),(\z -> (20,2):z)] `bindList`
      (`mapList` [[(50,0)],[(50,1)]])</span><span class="fragment initial-front" data-fragment-index="10" id="sequence-liftpartial">liftList (:) [(50,0),(50,1)] [[]] 
  = (mapList (:) [(50,0),(50,1)]) `bindList` (`mapList` [[]])
  = [(\x -> (50,0):x), (\y -> (50,1):y)] `bindList` (`mapList` [[]])</span>



</code></pre>
				</section>
				<section>
					<h3>Monad Type Class</h3>
<pre><code class="haskell">class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a

<span class="fragment">instance Monad Maybe where
  Nothing >>= f = Nothing
  Just a >>= f = f a  
  return a = Just a</span>

<span class="fragment">instance Monad [] where
  l >>= f = foldr (\x acc -> f x ++ acc) [] l  
  return x = [x]</span>

<span class="fragment">fmap :: Monad m => (a -> b) -> m a -> m b</span>
<span class="fragment">fmap f ma = ma >>= (\a -> return (f a))</span>

<span class="fragment">liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c</span>
<span class="fragment">liftM2 f ma mb = (fmap f ma) >>= (`fmap` mb)</span>

<span class="fragment">sequence :: Monad m => [m a] -> m [a]</span>
<span class="fragment">sequence l = foldr (m acc -> liftM2 (:) m acc) (return []) l</span>
</code></pre>
				</section>
				<section>
				<div>
					<h3>Monad's Secret Weapon:<br>The Monad Library</h3>
					</p>
					<ul>
						<li>sequence</li>
						<li>ap</li>
						<li>liftM2</li>
						<li>join</li>
						<li>filterM</li>
						<li>forM</li>
						<li>foldM</li>
						<li>when</li>
						<li>...and dozens more</li>
					</ul>
				</div>
				<div class="fragment explosion" style="position:absolute; z-index:2; top:50px; left:500px;">
				    <img src="images/pow.png" style="background: none; border: none; box-shadow: none;"/>
				</div>
				</section>
				</section>
				<section>
				<section>
					<div style="position: fixed; left: 4%"><img src="images/context-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; top: 50%; left: 3%"><img src="images/purpose-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
					<img src="images/monadman-lgr.png" style="background: none; border: none; box-shadow: none;" width="513px"/>
					<div style="position: fixed; left: 70%; top: 1%"><img src="images/costume-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
					<div style="position: fixed; left: 71%; top: 49%"><img src="images/powers-highlighted.png" style="background: none; border: none; box-shadow: none;"/></div>
            			</section>
				<section>
					<span>"Once you understand <strong>monads</strong>, you start seeing them everywhere — they're very general tools, and they can be used to solve a wide variety of problems. As with any other abstraction, you can do without <strong>monads</strong>. But if one abstraction solves so many problems so elegantly, it's worth learning about." -&nbsp;<a href="http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes" target="_blank">Eric&nbsp;Kidd</a></span>
				</section>
				</section>
				<section>				
				<section>
					<h2>Links, References and&nbsp;Credits</h2>
					<img src="images/book-cat.jpg" style="background: none; border: none; box-shadow: none; width: 700px;"/>					
            			</section>
				<section>
					<h3>Code Credits</h3>
					<ul>
					    <li><a href="http://github.com/mariofusco/javaz" target="_blank">Mario Fusco: Javaz</a></li>
					    <li><a href="http://github.com/tonymorris/course" target="_blank">Tony Morris: Course</a></li>
					</ul>
    				</section>
				<section>
					<h3>Image Credits</h3>
					<ul>
					    <li><a href="http://openclipart.org" target="_blank">Open Clip Art Library</a></li>
					    <li><a href="http://www.heromachine.com" target="_blank">HeroMachine</a></li>
					    <li><a href="http://www.flickr.com/photos/karenblixen/6893543810/" target="_blank">Book cat</a></li>
					    <li><a href="http://www.flickr.com/photos/theyoungthousands/1572001836/in/photostream/" target="_blank">Hero dog</a></li>
					</ul>
    				</section>
				<section>
					<h3>References</h3>
					<ul>
					    <li><a href="http://www.serpentine.com/blog/2008/01/17/the-monad-squad" target="_blank">The Monad Squad</a></li>
					    <li><a href="http://www.codecommit.com/blog/ruby/monads-are-not-metaphors" target="_blank">Monads Are Not Metaphors</a></li>
					    <li><a href="http://web.archive.org/web/20130125062147/http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes" target="_blank">Monads in 15 Minutes</a></li>
					</ul>
    				</section>
				<section>
					<h3>Recommended Reading</h3>
					<ul>
					    <li><a href="http://learnyouahaskell.com" target="_blank">Learn You A Haskell</a></li>
					    <li><a href="http://pragprog.com/book/vsjava8/functional-programming-in-java" target="_blank">Functional Programming in Java</a></li>
					    <li><a href="http://www.haskell.org/haskellwiki/Typeclassopedia" target="_blank">Typeclassopedia</a></li>
					    <li><a href="http://www.haskell.org/haskellwiki/Monad_tutorials_timeline" target="_blank">Monad Tutorials</a></li>
					</ul>
    				</section>
				</section>
				<section>
				<section>
					<h2>Questions?</h2>
            				<h3>Slides: <br><a href="http://monads.codemiller.com">monads.codemiller.com</a></h3>
					<img src="images/super-dog.jpg" style="background: none; border: none; box-shadow: none; width: 420px;"/>
            				<h3>Code: <br><a href="http://github.com/codemiller/superhero-monads" target="_blank">github.com/codemiller<br />/superhero-monads</a><h3>			
            			</section>
				</section>	
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
